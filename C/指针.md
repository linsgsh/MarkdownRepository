---
title: 指针
date: 2019-06-23 13:10:30
tags:
---

### 一、变量引言

#### 1、概念

(1)变量有自己的变量名、所属的变量类型、存储在内存的地址值和变量本身的值

(2)变量名：

(3)变量类型：整数类型、浮点数类型、字符类型、字符串类型和指针类型

(4)内存地址：不同类型的变量,用于存储值所占用的内存大小不同

(5)变量值：普通变量存的值该变量类型的值,指针变量存的值是内存地址

#### 2、类型：

(1)普通变量：整数类型变量、浮点数类型变量、字符类型变量和字符串类型变量

(2)指针变量： 指针类型变量                                                                                                                                                                            



### 二、指针变量

#### 1、概念：

(1) 指针本身一个值为内存地址的**变量**

(2)本质是一个变量,用于保存内存地址

#### 2、类型

(1)指针类型：指针变量是一个指针类型的变量

(2)指向的变量类型：指针变量指向的变量的类型

#### 3、值

(1)指针的值：存储某个变量的内存地址的值

(2)指针内存地址值：指针变量本身的内存地址值

(3)打印：指针值或者指针内存地址值都是用%p格式

#### 4、声明

(1)声明、不初始化

```c
//格式：指针指向的变量类型  指针类型 指针变量名
 Type  *p;
```

(2)声明、初始化

```c
//格式：指针指向的变量类型 指针类型 指针变量名 = 值; 
Type  *p = value;
```

(3)*声明：必须要知道指针所指向的变量的类型

(4)声明：*代表声明的变量类型是指针类型

(5)对指针变量初始化或者赋值的值是一个内存地址值,不是一个普通的值

#### 5、总结

 已知一个声明并初始化的指针p

```c
//格式：指针指向的变量类型 指针类型 指针变量名 = 值; 
Type  *p = value;

```

(1)信息一：指针变量p所指向的变量的类型

(2)信息二：指针变量p所指向的变量的地址

(3)信息三：指针变量p所指向的变量的值



### 三、指针类型

#### 1、符号表

<table>
    <tr>
        <th>优先级</th>
        <th>运算符</th>
        <th>名称/含义</th>
        <th>使用形式</th>
        <th>结合方向</th>
    </tr>
   <tr>
   		<td>1</td>
	    <td>[]</td>
	    <td>数组下标</td>
	    <td>数组名[整型表达式]</td>
	    <td>左到右</td>
	</tr>
    <tr>
        <td>1</td>
	    <td>()</td>
	    <td>函数</td>
	    <td>(表达式）/函数名(形参表)</td>
	    <td>左到右</td>
    </tr>
	<tr>
	    <td>2</td>
	    <td>*</td>
	    <td>取值运算符</td>
	    <td>*指针类型表达式</td>
	    <td>左到右</td>
	</tr>
</table>



#### 2、数组与指针

(1)数组指针：指向一个数组的指针

```c
//数组指针 ,接着是[],表明指向一个数组的指针
int (*p)[n];

//首先()和[]优先级一样,结合性按从左到右,所以p是一个指针
//接着由[]可以知道p是指向一个int类型数组的指针
```

(2)指针数组：存储的元素都是指针的数组

```c
//指针数组
int *p[n];

//首先[]优先级比*高,p与[]结合,表明是一个数组
//接着是int *,则表明数组元素是指向int类型变量的指针
```



#### 3、函数与指针

(1)函数指针：指向一个函数的指针

```c

```

(2)指针函数：返回一个指针的函数

```c

```

#### 4、结构体指针：

 指向一个结构体的指针



#### 4、指针级别

(1)一级指针：指向一个非指针类型的变量的指针

(2)二级指针：指向一个指针的指针



### 四、指针与常量

#### 1、指针常量

  指针常量：指针的地址是一个常量

```c
//声明并初始化一个int类型变量
int n = 10;

//指针的值是一个常量,即指针不能指向其他相同类型变量,只能指向该变量(声明指针时初始化指针的值)
int* const p = &n;

//虽然指针不能指向其他变量,但是可以修改指向的变量的值
*p = 99;

//指针常量：指针的值不能改变,但是可以修改指向的内存地址上保存的值
```



#### 2、常量指针

(1)常量指针：指针可以访问但是不能修改该指针指向的变量的值,对于指针来说该变量值不可改变

(2)指针指向的变量：本身可能是常量,可能是变量(取决于该变量是否是const修饰)

(3)常量指针的const是用于限制指针的行为,而不是限制指向的变量

````c
//声明并初始化一个int类型变量
int n = 10;

//定义一个指向变量n的指针
const int *p = &n;   

//可以访问指针指向的变量的值
pintf("%d",*p);

//但是不能通过该指针去修改变量的值
*p = 100; (x)

//变量本身值可能可以改变
n = 100;(可以)
````



#### 3、常量用法

(1)修饰普通变量

```c
//类型  const  变量名 = 值 
Type const  variable = value;

//const  类型  变量名 = 值
const Type  variable = value;

//在声明变量的时候必须进行初始化,不能在声明时不初始化,等到赋值的时候再赋于值

//声明、初始化后,变量值不能改变,即不能通过赋值改变其值
```

(2)指针变量

```c
//定义2个变量m和n
int m = 5, n =3;

//定义一个常量指针p
int * const  p = &m;

//访问p指向的变量的的值
printf("%d\n", *p);

//修改p指向的变量的值
*p = 1;
printf("%d", *p);

//但是不能让p指向其他变量
p = &n;

```

#### 4、总结

(1)const  int  *p：指针常量(指向一个常量的指针)

(2)int  const  *p：指针常量(指向一个常量的指针)

(3)int*  const  p：常量指针(指针的值是一个常量)

(4)指针常量：指针的地址是一个常量

(5)常量指针：指针指向的地址保存的值是常量(对于该指针来说是常量)



### 五、指针基本运算

#### 1、赋值=

(1)赋值给指针变量的值是一个内存地址值

```c
//声明一个指针变量p
Type *p;

//指针变量名 = 值
 p = value;
```

(2)&间接寻址赋值：通过&间接寻址符获取该变量的内存地址

```c
//定义一个指针变量和普通变量
Type *p, variable = N;

//&变量：获取该变量的地址
p = &variable; 
```

(3)指针赋值：通过将另一个指针变量赋值方式

```c
//声明和初始化一个普通变量
Type variable = N;

//声明和初始化一个指针变量p1
Type *p1 = &variable;

//声明一个指针变量p2
Type *p2

//把指针变量p1的值赋值给指针变量p2
p2 = p1;
```

(4)数组名赋值：通过数组名赋值(本质上数组名是一个指针变量)

```c
//定义一个数组和指针变量
Type array[N], *p;

//数组名赋值给指针变量(不需要&)
p = array;

//数组名的地址和数组第一个元素的地址是一样的(数组元素赋值需要&)
p = &array[0];
```

#### 2、间接寻址运算符/解引用*

(1)间接寻址运算符*：获取指针变量所指向的变量的值

(2)声明*：声明该变量是一个指针类型变量

(3)解引用*：获取指针变量所指向的变量的值

```c
//声明和初始化一个普通变量
Type variable = N;

//声明和初始化一个指针变量p(此时*代表指针变量p是一个指向类型的变量)
Type *p = &variable;

//访问指针所指向的变量的值(此时*代表解引用,即访问值)
*p;
```

#### 3、取地址值符&

 取地址值符&：获取普通变量和指针变量的内存地址

```c
//声明一个指针变量p
Type *p;

//访问指针变量p自身的内存地址
&p;
```

#### 4、打印指针

```c
//声明和初始化一个普通变量
Type variable = N;

//声明和初始化一个指针变量p(此时*代表指针变量p是一个指向类型的变量)
Type *p = &variable;

//打印指针p的内存地址
printf("%p", &p);

//打印指针变量p所指向的变量的地址
printf("%p", p);

//打印指针变量p所指向的变量的值
printf("%p", *p);

//打印指针指向的变量的地址
printf("%p", &variable);

//判断指针p是否指向variable
p == &variable;
```

#### 5、运算总结

(1)&p：获取指针变量p本身的内存地址值

(2)*p：获取指针变量p所指向的变量的值

(3)p：获取指针变量p所指向的变量的地址值



### 六、指针算术运算(处理数组)

#### 1、指针递增++

```c
//定义一个数组和指针变量
Type array[N], *p;

//数组名赋值给指针变量(此时p指向数组第一个元素)
p = array;

//测试指针p是否指向第一个元素
p == &array[0];

//指针递增(此时p指向数组第二个元素)
p++;

//测试指针p是否指向第二个元素
p == &array[1];
```

#### 2、指针递减--

```c
//定义一个数组和指针变量
Type array[N], *;

//数组第i个元素得到地址赋值给指针变量(此时p指向数组第i个元素)
p = &array[i];(0 < i < N)

//指针递减(此时p指向第i个的前一个元素,即第i-1个位置的元素)
p--;

//测试指针p是否指向第i-1个元素
p == &array[i - 1];
```

#### 3、指针加上整数

```c
//定义一个数组和指针变量
Type array[N], *p;

//数组第i个元素得到地址赋值给指针变量(此时p指向数组第i个元素)
p = &array[i];(0 < i < N)

//指针加一个整数(此时指针变量p指向第i+j个元素)
p += j;(j > 0, i + j < N)

//测试指针p是否指向第i+j个元素
p == &array[i + j];
```

#### 4、指针减去整数

```c
//定义一个数组和指针变量
Type array[N], *p;

//数组第i个元素得到地址赋值给指针变量(此时p指向数组第i个元素)
p = &array[i];(0 < i < N)

//指针减去一个整数(此时指针变量p指向第i-j个元素)
p -= j;(j > 0, i - j > 0)

//测试指针p是否指向第i+j个元素
p == &array[i - j];
```

#### 5、指针相减

 前提条件：分别指向同一个数组中两个不同位置的两个指针

```c
//定义一个数组和指针变量
Type array[N], *p1, *p2;

//数组第i个元素得到地址赋值给指针变量(此时p1指向数组第i个元素)
p1 = &array[i];(0 < i < N)

//数组第j个元素得到地址赋值给指针变量(此时p2指向数组第j个元素)
p2 = &array[j];(0 < j < N) 

//两个指针相减的值的绝对值是p1和p2两个指针指向的元素的位置的差值(即 i - j)
int value = p1 - p2;

//判断绝对值是否相等
|value| == |i - j|;
```



### 七、指针与数组

#### 1、指针方式遍历数组(*p)

```c
//定义一个数组a(N > 0)和一个指针变量
int a[N], *p = a;

//循环遍历数组的元素
for(p = &a[0]; p < &a[N]; p++) {
    printf("%d", *p);
}
```



#### 2、数组名作为指针

(1) 数组名可作为指向数组第一个元素的的指针

```c
//定义一个数组a(N > 0),此时a可以当做一个指向数组第一个元素位置的指针
int a[N];

//判断数组名地址是否是第一个元素的地址
a == &a[0];
```



(2)数组名以指针方式(指针算术运算和基本运算)访问/修改数组元素的值

```c
//此时a代表指向第i个元素位置的指针(0 < i <N)
a + i;

//表示获取第i个元素位置的内存地址
&a[i];

//判断是否相同
a + i == &a[i];

//访问第i个位置的值(指针方式访问)
*(a + i);

//修改第j个位置的值(指针方式修改)
*(a + j) = m;
```



(3)数组名作为指针遍历数组

```c
//定义一个数组a(N > 0)和一个指针变量
int a[N], *p = a;

//使用p = a代替p = &a[0],因为数组名可以当做是指向数组第一个元素的指针
for(p = a; p < a + N ;p++) {
	printf("%d", *p);
}
```



(4)数组名总结

```c
int a[N];

printf("%p\n", &a);
printf("%p\n", a);

//数组的地址
&a;

//数组首元素的地址
&a[0];

//数组的地址和数组首元素的地址的值相同(含义不同)
&a == &a[0]
```





#### 3、数组方式遍历数组(array[i])

```c
//定义一个数组a(N > 0)和变量
int a[N], i;

//遍历数组
for(i = 0; i < N; i++) {
    printf("%d", a[i]);
}
```



#### 4、指针作为数组名

 指针作为数组名,则指针变量可以当做数组名,采用数组方式访问/修改数组元素的值

```c
//定义一个数组a(N > 0)和一个指针变量
int a[N], i; *p = a;

for(i = 0; i < N; i++) {
    //指针当做数组名,然后按照数组方式访问或修改数组元素的值
    printf("%d", p[i]);
}
```



### 八、指针用途

#### 1、指针作为函数形式参数

(1)传入普通变量

a、基本类型变量：函数传入的变量是副本,在函数内修改副本值,对原变量不会有任何影响

b：结构体变量：函数传入的变量是副本，一来复制结构体变量占用的内存和消耗的时间大;二来如果要修改结构体,不会修改原版结构体



(2)函数修改参数值

```c
#include<stdio.h>

//声明一个交换方法1的函数原型,传入的参数是int类型参数
void swap1(int max, int min);

//声明一个交换方法2的函数原型,传入的参数是int类型的指针参数
void swap2(int *max, int *min)

int main(void) {
    int max = 1, min = 100;
    swap1(int max, int min);
    printf("max = %d, min = %d\n", max, min);
    swap2(int *max, int *min);
    printf("max = %d, min = %d\n", max, min);
}

//定义一个交换的函数,传入的参数是int类型参数
void swap1(int max, int min) {
    int temp;
    
    if(max < min) {
        temp = max;
        max = min;
        min = temp;
    }
}

//定义一个交换的函数,传入的参数是int类型的指针参数
void swap2(int *max, int *min) {
    int *temp;
    
    if(max < min) {
        temp = max;
        max = min;
        min = temp;
    }
}
```



(3)函数传入数组

```c
#include<stdio.h>

#define N 5

//声明一个打印数组的函数1原型,形参是一个数组
void printf_array1(int array[], int n);

//声明一个打印数组的函数2原型,形参是一个指针
void printf_array2(nt *array, int n);

int main(void) {
	int array[N] = {1, 2, 3, 4, 5};
    
    printf_array1(array, N);
    printf("\n");
    printf_array2(array, N);
}

//定义一个打印数组的函数,形参是一个数组(以数组方式打印)
void printf_array1(int array[], int n) {
    int i;
    
    for(i = 0; i < n; i++) {
        printf("%d ", array[i]);
    }
}

//定义一个打印数组的函数,形参是一个指针(以指针方式打印)
void printf_array2(nt *array, int n) {
    int *p;
    
    for(p = array; p < array + n; p++) {
        printf("%d ", *p);
    }
}
```

(4)函数传入结构体



#### 2、指针作为函数返回值

(1)返回值是指针类型,必须也要指出函数返回的指针类型是指向什么类型的变量

(2)*代表返回的类型是指针类型,Type代表返回的指针类型是指向的变量的类型

```c
//返回的指针指向的变量的类型 *函数名(形式参数)   
Type  *function_name(agrs...) {
```

(3)返回的指针类型：不能是指向函数里形式参数、局部变量(包括数组),因为形参和局部变量在调用完函数后会销毁

(4)例子

```c
#include<stdio.h>

#define N 5

typedef struct Person {
    id int;
    name char*;
    age int;
    address char*;
};

//声明一个返回值为[指向Person类型变量的]指针类型的函数
int *create_person();

int main(void) {
    //声明一个int类型的指针p
    int *person;
    
    //给指针p赋值
    person = create_person(1001, "甲", 24, "FZ");
}

//定义一个返回值为[指向Person类型变量的]指针类型的函数
int *create_person(int id, char *name, int age, char *address) {
    Person *person = malloc(sizeof(Person));
    person->id = id;
    person->name = name;
    person->age = age;
    person->address = address;
    return person;
}
```