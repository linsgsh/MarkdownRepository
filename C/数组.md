---
title: 数组
date: 2019-07-07 16:55:46
tags:
categories: C语言
---


### 一、一维数组

#### 1、数组概念

(1)数组：含有多个数据值的数据结构,并且每个数据值具有相同的数据类型

(2)元素：数组的数据值

(3)声明数组：指明元素的数据类型和数量

```c
//Type：元素的数据类型   N：元素数量
Type array[N];
```

(4数组长度：整数常量表达式(一般采用宏定义)

```c
//第一种宏定义
#define N 10

/* 第二种计算
 * 数组长度(元素个数) = 数组所有元素所占用的内存大小 / 单个元素占用的内存大小 
 * 返回一个无符号的数,可以使用强制转换
 */
int len = (int)(sizeof(array) / sizeof(array[0]));
```

(5)数组下标：array[i]是一个左值

(6)常见数组操作

```c
int array[N];

int i;

//数组元素清空
for(i = 0; i < N;i++) {
    array[i] = 0;
}

//数组元素赋值
for(i = 0; i < N; i++) {
    scanf("%d", &array[i]);
}

int sum = 0;

//数组元素求和
for(i = 0; i < N; i++) {
    sum += array[i];
}
```



#### 2、数组名

(1)数组名的值是数组首元素的首地址,所以在数值上**数组名可以当做是一个指针,指向数组首元素首地址**

(2)数组名是一个常量,不是一个变量，不能修改数组名的值,所以只能当右值，不能当做左值



(3)数组名在2个地方不能当做指针使用

```c
//获得数组的所有元素所占的字节总数
sizeof(数组名);
    
//获得数组的地址(数值上等于数组首元素的首地址)
&数组名;
```



(4)数组地址

**数组地址的值等于数组首元素的首地址,但是二者含义不同,一个代表数组，一个代表元素**

```c
//定义数组长度的宏
#define N 3

//声明和初始化数组
int array[N] = {1, 2, 3};

//指针初始化的值为数组名的值,即指向数组首元素首地址
int *p1 = array;

//指针初始化的值为数组的地址,即指向数组首元素首地址
int (*p2)[N] = &array;

//打印结果
printf("%u\n", sizeof((*p1)));
printf("%u", sizeof((*p2)));
```



(5)&符号

  数组名可以赋值给一个指针,指向数组首元素的首地址，表示指向数据类型的是数组的首元素的数据类型

 &数组名也可以赋值给一个指针，也指向数组首元素的首地址，但表示指向的数据类型是数组(数据类型+长度)





#### 3、数组声明、初始化

(1)声明、初始化

  **数据类型  数组名[长度] = {常量表达式列表}**；

```c
//常量列表个数=数组定义长度,则每个元素按照指定的值进行初始化
int array[5] = {1, 2, 3, 4, 5};

/*
 * 当常量列表个数 < 数组定义长度
 * 则只按照常量列表的值进行初始化前len个元素(len表示常量列表个数),剩余元素值为0
 */
int a[5] = {1, 2};

//全部元素初始化为0
int a[5] = {0};
```

(2)非法初始化

```c
//初始化表达式为空
int a[5] = {};

//初始化常量表达式列表个数 > 数组长度
int a[5] = {1, 2, 3, 4, 5, 6};
```

(3)指定初始化(C99)

  **数据类型  数组名[长度] = {[下标i] = 值,  [下标j] = 值 ... [下标n] = 值,}**；

```c
//指定第2个和第10个元素的值,其余元素值为0
int array[200] = {[2] = 1, [10] = 9};
```

(4)初始化总结

```c
/*
 * 第一种数组只声明、元素全部不显示初始化
 * 元素值会被隐式初始化
 * 整数类型初始化不一定为0
 * 浮点数初始化为0.00
 * 字符类型初始化不一定为'\0'(表示空字符)
 */
int array[10];

/*
 * 第二种数组声明、显示初始化全部元素
 * 元素值根据初始化的常量表达式列表进行初始化
 */
int array[4] = {1, 2, 3， 4};

/*
 * 第三种数组声明、显示初始化部分元素
 * 元素值根据初始化的常量表达式列表进行初始化
 * 被初始化的元素个数是常量表达式列表的常量个数
 * 剩余元素值：整数类型初始化为0、浮点数初始化为0.00、字符类型初始化为'\0'(表示空字符)
 */
int array[6] = {1, 2, 3， 4};

/*
 * 第四种数组声明、显示初始化部分元素为0、0.00或者'\0'
 */
int array[6] = {0};

char chars[4] = {'\0'};

double d[2] = {0.00};
```



#### 4、元素赋值

```c
//只声明，不显示初始化元素值
int array[10];

//给元素赋值
array[0] = 1;

```

#### 5、sizeof运算

(1)数组：确定数组的大小(字节数)

(2)数组元素：确定数组元素的大小(字节数)

(3)元素个数 = 数组字节总数  / 单个元素字节数(数组每个元素类型一样,所以每个元素的字节数一样)

```c
//数组
int array[n];

//强制转换
int len = (int)(sizeof(array) / sizeof(array[0]));
```

#### 6、数组的赋值运算

(1对于两个相同类型的数组,不能将一个数组的数组名赋值给另一个数组的数组名

```c
//声明、显示初始化数组
int a[4] = {1, 2, 3, 4};

//声明、不显示初始化数组
int b[10];

//数组名赋值给另一个数组，非法且无效
b = a;
```



(2)元素逐个复制

```c
//声明、显示初始化数组
int a[4] = {1, 2, 3, 4};

//声明、不显示初始化数组
int b[10];

int i;

//数组名赋值给另一个数组，非法且无效
for(i = 0; i < 4; i++) {
    //逐个赋值元素的值
    b[i] = a[i];
}
```



(3)内存复制法

```c
//声明、显示初始化数组
int a[4] = {1, 2, 3, 4};

//声明、不显示初始化数组
int b[10];

//<string.h>的memcy()函数
memcpy(a, b, sizeof(a));
```



### 二、二维数组

#### 1、二维数组定义

(1)形式：  **Type array[M] [N]**

(2)M：表示行       N：表示列

(3)二维数组：二维数组元素个数是M, 其中每个元素都是一个一维数组，每个一维数组元素个数是N

(4)**一维数组的个数是行，一维数组的元素个数是列**

(5)array[i] [j]：表示二维数组第i行第j列的元素

(6)一维数组的元素个数相同

(7)二维数组：转化为一维数组

  元素：一维数组       元素个数：一维数组个数



#### 2、二维数组遍历

(1)二维数组行列遍历

```c
#define M 6
#define N 5

char array[M][N] = {{'L', 'i', 'n', 'u', 'x'}, {'R', 'e', 'd', 'i', 's'},
                    {'C', 'S', 'A', 'P', 'P'}, {'S', 'h', 'e', 'l', 'l'},
                    {'N', 'g', 'i', 'n', 'x'}, {'M', 'y', 'S', 'Q', 'L'}};

int i, j;

for(i = 0; i < M; i++) {
    for(j = 0; j < N; j++) {
        printf("%c", array[i][j]);
    }

    printf("\n");
}
```



(2)数组名遍历法



(3)指针遍历法



#### 3、二维数组与数组指针



### 三、常量数组

#### 1、const含义

(1)表示数组是常量

(2)元素的值不能修改

(3)数组元素要在声明时进行初始化，一经初始化后不能再给元素赋值

#### 2、const作用

(1)程序本身不会也不能修改数组元素

(2)告知编译器不打算修改数组元素

(3)任何试图修改数组元素的行为都是错误的

#### 3、常量数组用途

 **当数组作为函数的参数时，在函数中只是希望访问数组元素的值，但是不会修改元素的值**



### 四、C99变长数组

#### 1、变长数组

(1)  一般数组的数组长度在**程序编译时期**确定，并且可以有声明数组时可以有初始化常量表达式

(2)变长数组的数组长度在编译器时无法确定，在**程序运行时**才确定，在声明数组时没有初始化常量表达式

(3)程序编译时，由于长度没有确定，还未给数组分配内存空间，在程序执行时才给数组分配内存空间



#### 2、malloc函数

(1)根据指定的长度，返回一个具有指定长度的内存的地址(返回指针)

(2)在程序运行时确定数组长度，并给数组分配内存空间



### 五、指针与数组

#### 1、指针

(1)数组名在数值上可以当做一个指针，指向数组首元素的首地址

(2)数组名在2个地方不能当做指针使用

(3)数组名在其他地方可以当做一个指针使用

(4)函数中数组作为参数时，形参是数组名，实际上编译器传的一个指针，即使指向数组首元素的首地址的指针



#### 2、指针数组

(1)**一个存储指针的数组**， 本质上是一个数组，只是元素是指针

(2)形式

```c
#define N 10;

/*
 * []优先级高于*,所以p是一个数组
 * *用于修饰数组,表示是一个存储指针的数组
 */
int *p[N];
```



#### 3、数组指针

(1)**一个指向数组的指针**, 本质上是一个数组

(2)形式

```c
#define N 3;

int array[N] = {1, 2, 3};

/*
 * ()和[]优先级一样高且都是从左往右结合,所以先进行()运算
 * ()里有一个*,表示p是一个指针
 * []用于修饰指针，表示是一个指向数组的指针
 */
int (*p)[N] = &array;
```



#### 4、数组遍历

(1)数组下标遍历法:   **数组名[下标]**

```c
#define N 10

int array[N], i;

for(i = 0; i < N; i++) {
    printf("%d", array[i]);
}
```



(2)数组名遍历法(指针+下标)：***(p + i)**

```c
#define N 10

//数组和指针
int array[N], i, *p;

//数组名当指针使用法
for(i = 0; i < N; i++) {
    printf("%d", *(array + i));
}
```



(3)指针遍历法：***(p)**

```c
#define N 10

//数组和指针
int array[N], *p;

//指针法(数组名赋值给一个指针,使得指针指向数组首元素的首地址)
for(p = array; p < array + N; p++) {
    printf("%d", *p);
}
```



(4)数组遍历2个要素

  **数组名、数组长度**