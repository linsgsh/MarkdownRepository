---
title: 函数
date: 2019-07-07 20:00:43
tags:
categories: C语言
---

#### 一、函数定义

#### 1、函数定义

(1)函数定义位置：放在源文件

(2)结构

````c
返回值类型  函数名(形式参数) {
	变量声明;
	语句;
}
````

#### 2、返回类型

(1)函数不能返回数组类型

(2)返回类型为void表示函数没有返回值

(3)返回类型为void*表示函数返回一个通用指针类型的值,根据实际需要进行强制转换

(4)Type*表示函数返回一个指向Type类型变量的指针

(5)省略返回类型，C89假定返回的类型是int类型，C99则不合法

(6)返回类型为void的函数的函数体可以为空

#### 3、函数头

(1)返回值类型(函数类型)

 **Type、void(无返回值类型)**

**Type ***(指向特定类型的指针类型)、void***(通用类型指针)**

(2)函数名

  驼峰命名法(单词首字母大写)

 匈牙利命名法(单词之间以_连接,全部小写)

(3)函数参数

 带形式参数(参数个数、参数类型、参数名)

 不带参数(不填写或者void)

#### 4、函数变量

(1)函数内声明的变量专属于该函数

(2)其他函数不能对定义在该函数的变量修改

#### 5、形式参数

(1)非指针变量：传实际参数值的副本

(2)指针变量：传实际参数的地址/值(数组名)的副本

(3)典型形参：

   **数组(传入的是数组名，实际上是一个指向数组首元素首地址的指针)**

   **结构体(传一个指向结构体的指针)**

(4)const

 const修饰形参时表示在函数中只能访问但是不能修改形参的值(非指针形参本身的值或者指针形参指向的变量的值)

#### 6、函数体

(1)变量声明、初始化、赋值

(2)语句

6、参数值传递

(1)普通变量(基本数据类型)

  **形式参数是实际参数值的副本,函数中对形参的修改不会影响实参变化 **

(2)指针变量(数组、结构体)

  **形式参数是一个地址值,是实际参数地址的副本(非实参值的副本),函数中对形参修改可能会影响实参值变化 **



#### 7、指针类型形参

(1)用const修饰指针类型的形参时,在函数中指向类型形参仅仅是只读的,不能修改值,否则会报错(const Type * var)

```c
#define N 6

//定义一个int类型的数组
int array[N] = {1, 2, 3, 4, 5, 6}

//获取数组元素中的最大值(将数组设置为只读)
int get_max(const array, int N) {
    //定义一个最大值变量
    int max = array[0];
    
    //遍历数组(指针法遍历)
    for(int i = 0; i < N; i++) {
        if(max < *(array + i) {
            max = *(array + i);
        }
    }
    
    return max;
}
```



(2)在函数体中形参指向该类型的其他变量,从而不再指向原实参,则在函数中修改形参值,不会影响实参值

```c
//定义一个结点类型的结构体
typedef struct Node {
    int data;
    Node *next;
};

//声明一个产生结构体的函数原型
void create_node(Node *node);

//主函数
int main(void) {
    //声明一个Node类型的指针变量,初始化为NULL(代表不指向任何变量)
    Node *node = NULL;
    
    //调用产生结构体的函数
    create_node(node)；
        
    //用于判断node是否是NULL(间接验证create_node()函数调用是否对node实参有影响)
    if(node == NULL) {
        printf("node为NULL");
    } else {
        printf("node不为NULL");
    }
}

//产生结构体的函数定义
void create_node(Node *node) {
    //利用do-while循环 + malloc()函数产生一个不是NULL的内存地址
    do {
        node = (Node*)malloc(sizeof(Node));
    } while(node == NULL);
    
    node->data = 1;
    node->next = NULL;
}
```



### 二、函数调用

#### 1、函数调用

(1)本质：是一个**表达式语句**

(2)结构

```c
//函数名(实参列表);
```

#### 2、有返回值

(1)函数调用后会产生一个由函数返回的值

(2)当做一个右值,可以赋值给左值

(3)当做另一个函数的实参

(4)当做一个值,参与表达式运算

(5)丢弃函数的返回值

#### 3、无返回值



### 三、函数声明

#### 1、函数声明

(1)函数声明要和函数定义一致

(2)函数声明位置：一般放在头文件

(3)函数声明结构

```c
//返回类型   函数名(形式参数)
```

#### 2、函数原型作用

(1)为函数调用提供关于函数完整的描述信息

(2)实际参数的个数、实际参数的类型、返回值类型

(3)不需要显示形式参数名字



### 四、实际参数

#### 1、形式参数

 出现在**函数定义**中，以假名字表示函数调用时需要提供的值

#### 2、实际参数

 出现在**函数调用**中的表达式

#### 3、参数传递

(1)原理：值传递  

(2)形式参数是实际参数值的副本

#### 4、实际参数转换

(1)编译器在函数调用前遇到函数原型

 每个实际参数的值被隐式转换为相应的形式参数的类型的值

(2)编译器在函数调用前吗未遇到函数原型

   编译器按照默认实际参数提升

   float类型实际参数转换为double类型

   char、short类型实际参数转换为int类型



### 六、数组类型参数

#### 1、一维数组相关形式参数

(1)场合：函数声明、函数定义

(2)相关参数：数组名、数组长度(传入的数组长度实参不能比实际数组长度大)

(3)形式参数写法

```c
//数组表示法(表示参数是一个数组类型)
int sum_array(int array[], int len);

//指针表示法(表示实际传入的参数是一个指针)
int sum_array(int *array, int len);

//数组表示法(表示参数是一个数组类型)
int sum_array(int array[], int len) {
    
}

//指针表示法(表示实际传入的参数是一个指针)
int sum_array(int *array, int len){
    
}
```

#### 2、一维数组实际参数

(1)场合：函数调用

(2)相关参数：数组名、数组长度(传入的数组长度实参不能比实际数组长度大)

(3)调用函数：实际参数中传入的是**数组名和长度**,不是**数组名[]和长度**

(4)实际参数写法

```c
//定义数组长度
#define N 10;

//声明数组
int array[N];

//调用函数,传入参数
sum_array(array, N);
```

#### 3、变量数组形式参数(C99)

(1)函数定义

```c
/*
 * int n和int array[n]顺序不能反
 * 第一个n确定第二个参数array的长度
 */  
返回类型  函数名(int n, int array[n]) {
 	声明;
    语句;
}
```

(2)函数原型

````c
返回类型  函数名(int n, int array[n]);

返回类型  函数名(int n, int array[*]);

返回类型  函数名(int n, int [*]);
````



### 七、main函数

#### 1、不带命令行参数

```c
int main(void) {
    //返回0表示正常退出
	return 0;
    
    //正常退出
    //exit(0);
}
```



#### 2、带命令行参数

```c
//程序的命令行参数个数、程序的命令行参数数组
int main(int args, char* argv[]) {
    return 0;
}

//程序的命令行参数个数、程序的命令行参数数组
int main(int args, char** argv) {
    return 0;
}
```



#### 3、退出函数

(1)return 0;

(2)exit(0);

(3)return  表达式  =  exit(表达式);